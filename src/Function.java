package src;

import java.awt.*;
import java.io.CharArrayReader;
import java.lang.Math;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

/**
 * A mathematical function generated by user input.
 */
public class Function {

    // numerical digits
    private static final Set<String> DIGITS = new HashSet<>(Arrays.asList("0","1","2","3","4","5","6","7","8","9"));

    // functions
    private static final Set<String> FUNCTIONS = new HashSet<>(Arrays.asList(
        "sin", "cos", "tan", "csc", "sec", "cot", "abs", "max", "min", "sqrt"));
    
    // chars that can be used as independent vars (i.e. x)
    private static final Set<String> VARS = new HashSet<>(Arrays.asList("x"));

    // ops in here are right associative
    private static final Set<String> RIGHT_ASC = new HashSet<>(Arrays.asList("^"));

    // operations and precedence levels
    private static HashMap<String, Integer> operations = new HashMap<String, Integer>();

    private String functionString;
    private ArrayList<String> rpn;
    private ArrayList<Coordinate> functionNodes;

    private int nodeNumber;

    public Function(String functionString, int nodeNumber) {
        initializeOps();
        this.functionString = functionString;
        this.rpn = parseFunctionString(tokenize(functionString));
        this.nodeNumber = nodeNumber;
        createFunctionTree(nodeNumber);
    }

    private void initializeOps(){
        operations.put("^", 1);
        operations.put("*", 2);
        operations.put("/", 2);
        operations.put("+", 3);
        operations.put("-", 3);
    }

    public void setFunction(String functionString) {
        this.functionString = functionString;
        this.rpn = parseFunctionString(tokenize(functionString));;
        createFunctionTree(nodeNumber);
    }

    // group together numbers, functions longer than one character
    private ArrayList<String> tokenize(String functionString){
        int i = 0;
        int len = functionString.length();
        ArrayList<String> tokenized = new ArrayList<String>();
        while (i < len) {
            String token = functionString.substring(i, i+1);
            String funcToken = "";
            if (len - i >= 3) funcToken = functionString.substring(i, i+3);
            if(FUNCTIONS.contains(funcToken)) {
                 tokenized.add(funcToken);
                 i+=3;
            }
            else if(operations.containsKey(token) || VARS.contains(token) || token.equals("(")) {
                tokenized.add(token);
                i++;
            }
            else if(token.equals(")")) {
                tokenized.add(token);
                i++;
                // implicit multiplication (i.e. (x+2)(x+5) instead of (x+2)*(x+5))
                if(i != len){
                    token = functionString.substring(i, i+1);
                    if(!operations.containsKey(token) && !token.equals(")")) tokenized.add("*");
                }
            }
            else if(DIGITS.contains(token)) {
                int k = i;
                String result = "";
                while (k < len && DIGITS.contains(token)) {
                    result += token;
                    k++;
                    if(k != len) token = functionString.substring(k, k+1);
                }
                tokenized.add(result);
                // implicit multiplication (i.e. 5x instead of 5*x)
                if(k != len && !operations.containsKey(token) && !token.equals(")")) tokenized.add("*");
                i+=k-i;
            }
            else i++;
        }
        System.out.println(tokenized);
        return tokenized;
    }
    
    // parses a function and converts into RPN using the Shunting-Yard algorithm
    private ArrayList<String> parseFunctionString(ArrayList<String> tokens){
        int len = tokens.size();
        ArrayList<String> output = new ArrayList<String>();
        Stack<String> opStack = new Stack<String>();
        int i = 0;
        while (i < len) {
            String token = tokens.get(i);
            if (DIGITS.contains(token.substring(0,1)) || VARS.contains(token)) output.add(token);
            else if (FUNCTIONS.contains(token)) opStack.push(token);
            else if (operations.containsKey(token)){
                while ((opStack.size() != 0 && operations.containsKey(opStack.peek()))
                        && ((operations.get(opStack.peek()) < operations.get(token))
                        || (operations.get(opStack.peek()) == operations.get(token) && !RIGHT_ASC.contains(token)))
                        && (!opStack.peek().equals("("))) {
                    output.add(opStack.pop());
                }
                opStack.push(token);
            }
            else if (token.equals("(")) opStack.push(token);
            else if (token.equals(")")){
                while(!opStack.peek().equals("(")) output.add(opStack.pop());
                if(opStack.peek().equals("(")) opStack.pop();
            }
            i++;
        }
        while (opStack.size() > 0) output.add(opStack.pop());
        System.out.println(output);
        return output;
    }

    // evaluates the function at a given input value
    public double evalFunction(double x) {
        String xStr = Double.toString(x);
        Stack<String> evalStack = new Stack<String>();
        double result = 0;
        for (String s : rpn){
            if (VARS.contains(s)) evalStack.push(xStr);
            else if (DIGITS.contains(s.substring(0,1))) evalStack.push(s);
            else if (operations.containsKey(s)) {
                double val1 = Double.parseDouble(evalStack.pop());
                double val2 = Double.parseDouble(evalStack.pop());
                //System.out.println("Evaluating: " + val2 + s + val1);
                if(s.equals("^")) result = Math.pow(val2, val1);
                else if(s.equals("*")) result = val2 * val1;
                else if(s.equals("/")) {
                    if(val1 != 0)
                        result = val2 / val1;
                    else
                        result = -6969;
                }
                else if(s.equals("+")) result = val2 + val1;
                else if(s.equals("-")) result = val2 - val1;
                //System.out.println(result);
                evalStack.push(Double.toString(result));
            }
            else if (FUNCTIONS.contains(s)) {
                double val1 = Double.parseDouble(evalStack.pop());
                if(s.equals("sin")) result = Math.sin(val1);
                else if(s.equals("cos")) result = Math.cos(val1);
                else if(s.equals("tan")) result = Math.tan(val1);
                else if(s.equals("csc")) {
                    result = 1/Math.sin(val1);
                }
                else if(s.equals("sec")) {
                    result = 1/Math.cos(val1);
                }
                else if(s.equals("cot")) {
                    result = 1/Math.tan(val1);
                }
                else if(s.equals("max")) {
                    double val2 = Double.parseDouble(evalStack.pop());
                    result = Math.max(val1, val2);
                }
                evalStack.push(Double.toString(result));
            }
        }
        return Double.parseDouble(evalStack.pop());
    }

    private void createFunctionTree(int nodeNumber) {
        functionNodes = new ArrayList<Coordinate>();
        double scale = 6;
        double horizScale = scale/(double)(Frame.WIDTH/2);
        double vertScale = scale/(double)(Frame.HEIGHT/2);
        for(int i = -Frame.WIDTH/2; i <= Frame.WIDTH/2; i++) {
            double x = i*horizScale;
            double y = evalFunction(x)/horizScale;
            functionNodes.add(new Coordinate(i, (int)(y)));
            i+=Frame.WIDTH/nodeNumber;
        }
    }

    public void paintFunction(Graphics2D g) {
        for(int i = 0; i < functionNodes.size()-1; i++){
            Stroke stroke = new BasicStroke(6f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
            g.setStroke(stroke);
            g.setColor(Color.black);
            g.drawLine(functionNodes.get(i).getDisplayX(),functionNodes.get(i).getDisplayY(),functionNodes.get(i+1).getDisplayX(),functionNodes.get(i+1).getDisplayY());
        }
    }
}